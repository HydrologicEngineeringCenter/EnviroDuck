/*
 * MainWindow.java
 *
 */

package enviroduck;

/**
 *
 * @author  b4edhdwj
 */

import hec.heclib.dss.*;
import hec.heclib.util.*;
import hec.io.*;             // Has TimeSeriesContainer

import java.util.prefs.*;


/** class MainWindow
 *
 * This class provides the main GUI for the EnviroDuck Program */

public class MainWindow extends javax.swing.JFrame {

    /** MainWindow()
     *
     * Creates new form MainWindow */

    public MainWindow() {
        init();
        initComponents();
    }

    /** void finalize()
     *
     * cleanup the MainWindow on program exit */

    public void finalize() throws Throwable
    {
        closeDSSFile();

        super.finalize();
    }

    /** void init()
     *
     * INitalize the no GUI variables of the MainWindow class */

    private void init()
    {
        lastFile = null;
        fileLoaded = false;

        prefs = Preferences.userNodeForPackage(MainWindow.class);

        // Get the Stage data prefernece strings
        stageDataStrings = prefs.get("Stage Data Strings","ELEV");

        // Get the Stage Area preference strings
        stageAreaStrings = prefs.get("Stage Area Strings","ELEV-AREA");

        // Get the last file opened   
        String tmp = prefs.get("Last DSS File Opened","");
        if ( tmp.equals("") == false)
        {
            lastFile = new java.io.File(tmp);
        }

        // Get the ouput directory
        outputDirPath = prefs.get("Output Directory","");

        // the spawning depth range
        maxDepth = prefs.getFloat("Max Depth",1.5f);

        // Get the season info
        seasonStartMonth = prefs.getInt("Season Start Month",11);
        seasonStopMonth = prefs.getInt("Season Stop Month",2);
        seasonStartDay = prefs.getInt("Season Start Day",1);
        seasonStopDay = prefs.getInt("Season Stop Day",29);

        // Get the days to exaustion
        exaustionDays = prefs.getInt("Exaustion Days",30);

        // Get the depletion Days
        depletionDays = prefs.getInt("DepletionDays",120);

        //Get Debug Conditions
        recordDaily = prefs.getBoolean("Record Daily",false);
        stageDataStr = stageDataStrings.split(":");

        // force the stage area stings to update
        if (fileLoaded)
        {
            loadDSSFile();
        }
    }

    void resetPrefs()
    {
        // set the variables
        stageDataStrings = "ELEV";
        stageAreaStrings = "ELEV-AREA";
        maxDepth = 1.5f;

        seasonStartMonth = 11;
        seasonStopMonth = 2;
        seasonStartDay = 1;
        seasonStopDay = 29;
        recordDaily = false;

        // set the preferences
        prefs.put("Stage Data Strings",stageDataStrings);
        prefs.get("Stage Area Strings",stageAreaStrings);
        prefs.putFloat("Max Depth",maxDepth);
        prefs.putInt("Season Start Month",seasonStartMonth);
        prefs.putInt("Season Stop Month",seasonStopMonth);
        prefs.putInt("Season Start Day",seasonStartDay);
        prefs.putInt("Season Stop Day",seasonStopDay);
        prefs.putBoolean("Record Daily",recordDaily);

        //spawning Depth
        jMaxDepthText.setValue(maxDepth);

        //season duration
        jSeasonField.setText("" + seasonStartMonth + "/" + seasonStartDay + " - "
                + seasonStopMonth +  "/" + seasonStopDay);

        //boolean flags
        jCalcDailyCBox.setSelected(recordDaily);



    }

    /** This method is called from within the constructor to
     * initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is
     * always regenerated by the Form Editor.
     */
    private void initComponents() {//GEN-BEGIN:initComponents
        jDSSFilename = new javax.swing.JTextField();
        jScrollPane1 = new javax.swing.JScrollPane();
        jStageTable = new javax.swing.JTable();
        jStageTable.getSelectionModel().addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent e) {
                jStageTableValueChanged(e);
            }
        });
        jLabel1 = new javax.swing.JLabel();
        jDssFileBrowseButton = new javax.swing.JButton();
        jRunButton = new javax.swing.JButton();
        jPanel1 = new javax.swing.JPanel();
        try
        {
            yf1 = new javax.swing.text.MaskFormatter("####");
            yf1.setCommitsOnValidEdit(true);

        }
        catch (java.text.ParseException pe1)
        {
            yf1 = new javax.swing.text.MaskFormatter();
        }
        jStartText = new javax.swing.JFormattedTextField(yf1);
        jLabel2 = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();
        try
        {
            yf2 = new javax.swing.text.MaskFormatter("####");
            yf2.setCommitsOnValidEdit(true);

        }
        catch (java.text.ParseException pe1)
        {
            yf2 = new javax.swing.text.MaskFormatter();
        }
        jStopText = new javax.swing.JFormattedTextField(yf2);
        jButton1 = new javax.swing.JButton();
        jSeasonField = new javax.swing.JTextField();
        jSeasonField.setText("" + seasonStartMonth + "/" + seasonStartDay + " - "
                + seasonStopMonth +  "/" + seasonStopDay);
        jLabel4 = new javax.swing.JLabel();
        jScrollPane2 = new javax.swing.JScrollPane();
        jAreaTable = new javax.swing.JTable();
        jOutputPathField = new javax.swing.JTextField();
        jLabel8 = new javax.swing.JLabel();
        jOutputPathButton = new javax.swing.JButton();
        jPanel2 = new javax.swing.JPanel();
        jCalcDailyCBox = new javax.swing.JCheckBox();
        jCalcDailyCBox.getModel().setSelected(recordDaily);
        jRetainPeriodCBox = new javax.swing.JCheckBox();
        jPanel3 = new javax.swing.JPanel();
        jLabel7 = new javax.swing.JLabel();
        df2 = new javax.swing.text.NumberFormatter();
        df2.setAllowsInvalid(true);
        df2.setCommitsOnValidEdit(true);
        df2.setValueClass(Float.class);
        jMaxDepthText = new javax.swing.JFormattedTextField(df2);
        df = new javax.swing.text.NumberFormatter();
        df.setAllowsInvalid(false);
        df.setValueClass(Integer.class);
        jDurField = new javax.swing.JFormattedTextField(df);
        jLabel5 = new javax.swing.JLabel();
        df3 = new javax.swing.text.NumberFormatter();
        df3.setAllowsInvalid(false);
        df3.setValueClass(Integer.class);
        jDepletionField = new javax.swing.JFormattedTextField(df3);
        jLabel6 = new javax.swing.JLabel();
        jMenuBar = new javax.swing.JMenuBar();
        jFileMenu = new javax.swing.JMenu();
        jOpenMenuItem = new javax.swing.JMenuItem();
        jPrefsItems = new javax.swing.JMenuItem();

        getContentPane().setLayout(null);

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);
        setTitle("Enviro Duck  1.0.1");
        setResizable(false);
        jDSSFilename.setToolTipText("The path to the DSS File");
        getContentPane().add(jDSSFilename);
        jDSSFilename.setBounds(90, 10, 430, 19);

        jStageTable.setModel(new javax.swing.table.DefaultTableModel(
                new Object [][] {

                },
                new String [] {
                        "A Part", "B Part", "C Part", "D Part", "E Part", "F Part"
                }
        ) {
            boolean[] canEdit = new boolean [] {
                    false, false, false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        stagePathsModel = (javax.swing.table.DefaultTableModel) jStageTable.getModel();
        jScrollPane1.setViewportView(jStageTable);

        getContentPane().add(jScrollPane1);
        jScrollPane1.setBounds(10, 90, 610, 140);

        jLabel1.setText("DSS File");
        getContentPane().add(jLabel1);
        jLabel1.setBounds(10, 10, 60, 14);
        jLabel1.getAccessibleContext().setAccessibleName("");

        jDssFileBrowseButton.setText("Browse ...");
        jDssFileBrowseButton.setToolTipText("Select a DSS file");
        jDssFileBrowseButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                MainWindow.this.actionPerformed(evt);
            }
        });

        getContentPane().add(jDssFileBrowseButton);
        jDssFileBrowseButton.setBounds(530, 10, 90, 23);

        jRunButton.setText("Run");
        jRunButton.setToolTipText("Calculate duck acres for the selected are and time period.");
        jRunButton.setEnabled(false);
        jRunButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jRunButtonActionPerformed(evt);
            }
        });

        getContentPane().add(jRunButton);
        jRunButton.setBounds(530, 470, 90, 23);

        jPanel1.setLayout(null);

        jPanel1.setBorder(new javax.swing.border.TitledBorder(null, "Season Constrants", javax.swing.border.TitledBorder.CENTER, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Tahoma", 0, 11), new java.awt.Color(0, 0, 0)));
        jStartText.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jStartTextFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                jStartTextFocusLost(evt);
            }
        });

        jPanel1.add(jStartText);
        jStartText.setBounds(60, 20, 50, 21);

        jLabel2.setText("Period");
        jPanel1.add(jLabel2);
        jLabel2.setBounds(10, 20, 40, 14);

        jLabel3.setText("to ");
        jPanel1.add(jLabel3);
        jLabel3.setBounds(120, 20, 20, 14);

        jStopText.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jStopTextFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                jStopTextFocusLost(evt);
            }
        });

        jPanel1.add(jStopText);
        jStopText.setBounds(150, 20, 50, 21);

        jButton1.setText("Edit..");
        jButton1.setToolTipText("");
        jButton1.setMargin(new java.awt.Insets(2, 2, 2, 2));
        jButton1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton1ActionPerformed(evt);
            }
        });

        jPanel1.add(jButton1);
        jButton1.setBounds(150, 50, 50, 23);

        jSeasonField.setEditable(false);
        jSeasonField.setHorizontalAlignment(javax.swing.JTextField.CENTER);
        jSeasonField.setMargin(new java.awt.Insets(2, 2, 2, 2));
        jPanel1.add(jSeasonField);
        jSeasonField.setBounds(60, 50, 80, 20);

        jLabel4.setText("Season");
        jPanel1.add(jLabel4);
        jLabel4.setBounds(10, 50, 60, 14);

        getContentPane().add(jPanel1);
        jPanel1.setBounds(300, 410, 210, 80);

        jAreaTable.setModel(new javax.swing.table.DefaultTableModel(
                new Object [][] {

                },
                new String [] {
                        "A Part", "B Part", "C Part", "D Part", "E Part", "F Part"
                }
        ) {
            boolean[] canEdit = new boolean [] {
                    false, false, false, false, false, false
            };

            public boolean isCellEditable(int rowIndex, int columnIndex) {
                return canEdit [columnIndex];
            }
        });
        areaPathsModel = (javax.swing.table.DefaultTableModel) jAreaTable.getModel();
        jAreaTable.setOpaque(false);
        javax.swing.DefaultListSelectionModel sm1 = new javax.swing.DefaultListSelectionModel();
        sm1.setSelectionMode(javax.swing.ListSelectionModel.SINGLE_SELECTION);
        jAreaTable.setSelectionModel(sm1);
        jAreaTable.getSelectionModel().addListSelectionListener(new javax.swing.event.ListSelectionListener() {
            public void valueChanged(javax.swing.event.ListSelectionEvent e) {
                jAreaTableValueChanged(e);
            }
        });
        jScrollPane2.setViewportView(jAreaTable);

        getContentPane().add(jScrollPane2);
        jScrollPane2.setBounds(10, 240, 610, 150);

        if ( ! outputDirPath.equals("") )
        {
            jOutputPathField.setText(outputDirPath);
        }
        jOutputPathField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jOutputPathFieldActionPerformed(evt);
            }
        });

        getContentPane().add(jOutputPathField);
        jOutputPathField.setBounds(90, 50, 430, 19);

        jLabel8.setText("Output Path");
        getContentPane().add(jLabel8);
        jLabel8.setBounds(10, 50, 70, 14);

        jOutputPathButton.setText("Browse ...");
        jOutputPathButton.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jOutputPathButtonActionPerformed(evt);
            }
        });

        getContentPane().add(jOutputPathButton);
        jOutputPathButton.setBounds(530, 50, 90, 23);

        jPanel2.setLayout(null);

        jCalcDailyCBox.setText("Calc Daily");
        jCalcDailyCBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jCalcDailyCBoxActionPerformed(evt);
            }
        });

        jPanel2.add(jCalcDailyCBox);
        jCalcDailyCBox.setBounds(0, 20, 90, 23);

        jRetainPeriodCBox.setText("Static Period");
        jPanel2.add(jRetainPeriodCBox);
        jRetainPeriodCBox.setBounds(0, 0, 100, 23);

        getContentPane().add(jPanel2);
        jPanel2.setBounds(520, 410, 100, 50);

        jPanel3.setLayout(null);

        jPanel3.setBorder(new javax.swing.border.TitledBorder(null, "Feeding Constrants", javax.swing.border.TitledBorder.CENTER, javax.swing.border.TitledBorder.DEFAULT_POSITION, new java.awt.Font("Tahoma", 0, 11), new java.awt.Color(0, 0, 0)));
        jLabel7.setText("Max Depth");
        jPanel3.add(jLabel7);
        jLabel7.setBounds(140, 20, 70, 14);

        jMaxDepthText.setValue(maxDepth);
        jMaxDepthText.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jMaxDepthTextActionPerformed(evt);
            }
        });

        jPanel3.add(jMaxDepthText);
        jMaxDepthText.setBounds(210, 20, 30, 21);

        jDurField.setToolTipText("");
        jDurField.setValue(exaustionDays);
        jDurField.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jDurFieldActionPerformed(evt);
            }
        });
        jDurField.addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                jDurFieldFocusGained(evt);
            }
        });

        jPanel3.add(jDurField);
        jDurField.setBounds(100, 20, 30, 21);

        jLabel5.setText("Exaustion Days");
        jPanel3.add(jLabel5);
        jLabel5.setBounds(10, 20, 90, 14);

        jDepletionField.setValue(depletionDays);
        jPanel3.add(jDepletionField);
        jDepletionField.setBounds(100, 50, 30, 21);

        jLabel6.setText("Depletion Days");
        jPanel3.add(jLabel6);
        jLabel6.setBounds(10, 50, 90, 14);

        getContentPane().add(jPanel3);
        jPanel3.setBounds(10, 410, 270, 80);

        jFileMenu.setText("File");
        jOpenMenuItem.setText("Open");
        jOpenMenuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                MainWindow.this.actionPerformed(evt);
            }
        });

        jFileMenu.add(jOpenMenuItem);

        jPrefsItems.setText("Preferences ...");
        jPrefsItems.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jPrefsItemsActionPerformed(evt);
            }
        });

        jFileMenu.add(jPrefsItems);

        jMenuBar.add(jFileMenu);

        setJMenuBar(jMenuBar);

        java.awt.Dimension screenSize = java.awt.Toolkit.getDefaultToolkit().getScreenSize();
        setBounds((screenSize.width-642)/2, (screenSize.height-562)/2, 642, 562);
    }//GEN-END:initComponents

    private void jOutputPathFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jOutputPathFieldActionPerformed
        outputDirPath = jOutputPathField.getText();
        prefs.put("Output Directory",outputDirPath);
    }//GEN-LAST:event_jOutputPathFieldActionPerformed

    /** jCalcDailyCBoxActionPerformed(java.awt.event.ActionEvent evt)
     *
     * This function is called by the "calc daily" check box it determins if
     * daily data is recorded */

    private void jCalcDailyCBoxActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jCalcDailyCBoxActionPerformed
        recordDaily = jCalcDailyCBox.getModel().isSelected();
        prefs.putBoolean("Record Daily",recordDaily);
    }//GEN-LAST:event_jCalcDailyCBoxActionPerformed

    /** jOutputPathButtonActionPerformed(java.awt.event.ActionEvent evt)
     *
     *  This method is called by the browse button beside the output path display field.
     *  It displays a file browser for the user to choose an output directory */

    private void jOutputPathButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jOutputPathButtonActionPerformed

        javax.swing.JFileChooser  fc;

        fc = new javax.swing.JFileChooser ();               // make the file chooser
        fc.setFileSelectionMode(fc.DIRECTORIES_ONLY);       // display files only
        fc.setCurrentDirectory( new java.io.File(outputDirPath) );                  // open the last directory

        int rval;
        rval = fc.showOpenDialog(this);       // show the dialog
        if ( rval == fc.CANCEL_OPTION )
        {
            return;
        }
        else if ( rval == fc.APPROVE_OPTION)
        {
            outputDirPath = fc.getSelectedFile().getAbsolutePath();
            jOutputPathField.setText( outputDirPath);

            prefs.put("Output Directory",outputDirPath);
        }
        else
        {
            // some error occured 
        }
    }//GEN-LAST:event_jOutputPathButtonActionPerformed

    /** jPrefsItemsActionPerformed(java.awt.event.ActionEvent evt)
     *
     * This methode is called by the Preferences menu item. It displays the prefernces dialog
     * After the Prefrences dialog is closed the control stringx for find gage data and stage
     * area curves are checked. If the control strings have changed update the display */

    private void jPrefsItemsActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jPrefsItemsActionPerformed
        PrefDialog pd = new PrefDialog(this,true);

        // set the strings displayed by the dialog
        pd.setDataList(stageDataStrings);
        pd.setAreaList(stageAreaStrings);

        // make a copy of the current strings
        String s1 = new String(stageDataStrings);
        String s2 = new String(stageAreaStrings);

        // show the dialog
        pd.setVisible(true);

        // if the user did not cancel
        if ( ! pd.cancel() )
        {
            // get the new strings from the dialog
            stageDataStrings = pd.getDataList();
            stageAreaStrings = pd.getAreaList();

            prefs.put("Stage Data Strings",stageDataStrings);
            prefs.put("Stage Area Strings",stageAreaStrings);
        }

        // if the data selection strings changed reload the DSS File
        if ( s1.equals(stageDataStrings) == false )
        {
            loadDSSFile();
        }
        else
        {

            // force the stage area stings to update if nessessary
            if ( s2.equals(stageAreaStrings) == false )
            {
                int pos = jStageTable.getSelectedRow();
                if ( jStageTable.getRowCount() > 0 && pos != -1 )
                {
                    jStageTable.clearSelection();
                    jStageTable.addRowSelectionInterval(pos,pos);
                }
            }
        }


    }//GEN-LAST:event_jPrefsItemsActionPerformed

    /** void jMaxDepthTextActionPerformed(java.awt.event.ActionEvent evt)
     *
     * This methode is called by the "Max Depth" display field. It makes 
     * the internal variable holding the maximum depth for the model trake the
     * value displayed in the field */

    private void jMaxDepthTextActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jMaxDepthTextActionPerformed
        if (jMaxDepthText.getValue() instanceof Integer)
        {
            Integer i = (Integer) jMaxDepthText.getValue();
            maxDepth = i.intValue();
        }

        prefs.putFloat("Max Depth",maxDepth);
    }//GEN-LAST:event_jMaxDepthTextActionPerformed

    private void jStopTextFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jStopTextFocusLost

    }//GEN-LAST:event_jStopTextFocusLost

    private void jStartTextFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jStartTextFocusLost

    }//GEN-LAST:event_jStartTextFocusLost

    private void jStopTextFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jStopTextFocusGained
        jStopText.selectAll();
    }//GEN-LAST:event_jStopTextFocusGained

    private void jStartTextFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jStartTextFocusGained
        jStartText.selectAll();
    }//GEN-LAST:event_jStartTextFocusGained

    private void jDurFieldFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_jDurFieldFocusGained
        jDurField.selectAll();
    }//GEN-LAST:event_jDurFieldFocusGained

    private void jDurFieldActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jDurFieldActionPerformed
        if (jDurField.getValue() instanceof Integer)
        {
            Integer i = (Integer) jDurField.getValue();
            exaustionDays = i.intValue();
        }

        prefs.putInt("Exaustion Days",exaustionDays);
    }//GEN-LAST:event_jDurFieldActionPerformed

    /** This opens a dialog box alowing a new time window to be selected */

    private void jButton1ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton1ActionPerformed
        // make the dialog
        DateDialog dd = new DateDialog(this,true);

        java.awt.Rectangle windowBounds;
        java.awt.Rectangle dialogBounds;
        windowBounds = getBounds();
        dialogBounds = dd.getBounds();

        dialogBounds.x = (int)(windowBounds.getCenterX() - (dialogBounds.getWidth() / 2));
        dialogBounds.y = (int)(windowBounds.getCenterY() - (dialogBounds.getHeight() / 2));
        dd.setBounds(dialogBounds);

        // set the displayed dates
        dd.setInitalMonth(seasonStartMonth);
        dd.setInitalDay(seasonStartDay);
        dd.setFinalMonth(seasonStopMonth);
        dd.setFinalDay(seasonStopDay);

        // show the dialog
        dd.setVisible(true);

        //get the new dates
        seasonStartMonth = dd.getInitalMonth();
        seasonStartDay = dd.getInitalDay();
        seasonStopMonth = dd.getFinalMonth();
        seasonStopDay = dd.getFinalDay();

        //write the new values to the preferences
        prefs.putInt("Season Start Month",seasonStartMonth);
        prefs.putInt("Season Start Day",seasonStartDay);
        prefs.putInt("Season Stop Month",seasonStopMonth);
        prefs.putInt("Season Stop Day",seasonStopDay);

        jSeasonField.setText("" + seasonStartMonth + "/" + seasonStartDay + " - "
                + seasonStopMonth +  "/" + seasonStopDay);

    }//GEN-LAST:event_jButton1ActionPerformed

    /** void jRunButtonActionPerformed(java.awt.event.ActionEvent evt)
     *
     * This methode is called by the run button. It sincs the internalo variables
     * with the GUI and calls runRange() */

    private void jRunButtonActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jRunButtonActionPerformed

        //force update of max depth
        try
        {
            jMaxDepthText.commitEdit();
        }
        catch( java.text.ParseException e )
        {

        }

        if (jMaxDepthText.getValue() instanceof Integer)
        {
            Integer i = (Integer) jMaxDepthText.getValue();
            maxDepth = i.intValue();
        }

        prefs.putFloat("Max Depth",maxDepth);

        //force update of Duration
        try
        {
            jDurField.commitEdit();
        }
        catch( java.text.ParseException e)
        {

        }

        // force update of duration field
        if (jDurField.getValue() instanceof Integer)
        {
            Integer i = (Integer) jDurField.getValue();
            exaustionDays = i.intValue();
        }
        prefs.putInt("Exaustion Days",exaustionDays);

        int firstYear = Integer.parseInt(jStartText.getText());
        int lastYear = Integer.parseInt(jStopText.getText());

        runRange(firstYear,lastYear,getWindowBeginStr(),getWindowEndStr());

    }//GEN-LAST:event_jRunButtonActionPerformed

    /** void jStageTableValueChanged(javax.swing.event.ListSelectionEvent e)
     *
     * This methode is called in response to table events in the gage table (upper table)
     */

    void jStageTableValueChanged(javax.swing.event.ListSelectionEvent e)
    {
        //Ignore extra messages.
        if (e.getValueIsAdjusting()) return;

        javax.swing.ListSelectionModel lsm =
                (javax.swing.ListSelectionModel)e.getSource();
        if (lsm.isSelectionEmpty())
        {
            //no rows are selected
        }
        else
        {
            // get the selected indes
            int idx = jStageTable.getSelectionModel().getMinSelectionIndex();

            // get the current path parts
            String[] dRange = ((String) stagePathsModel.getValueAt(idx,3)).split(" - ");

            //construct the inital path
            StringBuffer path = new StringBuffer();
            path.append("/");
            path.append(stagePathsModel.getValueAt(idx,0));
            path.append("/");
            path.append(stagePathsModel.getValueAt(idx,1));
            path.append("/");
            path.append(stagePathsModel.getValueAt(idx,2));
            path.append("/");
            path.append(dRange[0]);
            path.append("/");
            path.append(stagePathsModel.getValueAt(idx,4));
            path.append("/");
            path.append(stagePathsModel.getValueAt(idx,5));

            //set the path in the dss file
            currentPath = (path.toString());

            if ( ! jRetainPeriodCBox.isSelected() )
            {
                //set the window to incompass all data initally

                jStartText.setText(dRange[0].substring(5));
                float val = Float.parseFloat(dRange[1].substring(5));
                val -= 1;
                jStopText.setText(Float.toString(val));
            }

            // clear the stage area curve table
            areaPathsModel.setRowCount(0);

            String buffer;
            String[] parts;
            java.util.Vector paths = new java.util.Vector();

            // split the stage area string on ":"
            stageAreaStr = stageAreaStrings.split(":");

            // find all possible stage area curves by matching B part to the current data path and C part against
            // the strings in parts

            for(int k = 0; k < stageAreaStr.length; ++k)
            {
                // search the Catalog for matches
                CondensedReference[] cr = pd.getCondensedCatalog("/*/"+stagePathsModel.getValueAt(idx,1)+"/"+stageAreaStr[k]+"/*/*/*/");

                // display each stage area curve on a row
                for(int j = 0; j < cr.length; ++j)
                {
                    areaPathsModel.addRow(cr[j].toString().substring(1).split("/"));
                }

                // if any stageArea Paths where found reset the selection to the first path
                if (areaPathsModel.getRowCount() > 0 )
                {
                    jAreaTable.clearSelection();
                    jAreaTable.addRowSelectionInterval(0,0);
                }
            }


            jRunButton.setEnabled(true);
        }
    }

    /** void jAreaTableValueChanged(javax.swing.event.ListSelectionEvent e)
     *
     * This methode is called in response to table events in the stage area table (lower table)
     */

    private void jAreaTableValueChanged(javax.swing.event.ListSelectionEvent e)
    {
        //Ignore extra messages.
        if (e.getValueIsAdjusting()) return;

        javax.swing.ListSelectionModel lsm =
                (javax.swing.ListSelectionModel)e.getSource();
        if (lsm.isSelectionEmpty())
        {
            //no rows are selected
        } else
        {
            // retrieve the stage area path from the selected row
            int selectedRow = lsm.getMinSelectionIndex();
            pd.setPathname(  "/" + (String) areaPathsModel.getValueAt(selectedRow, 0) +
                    "/" + (String) areaPathsModel.getValueAt(selectedRow, 1) +
                    "/" + (String) areaPathsModel.getValueAt(selectedRow, 2) +
                    "/" + (String) areaPathsModel.getValueAt(selectedRow, 3) +
                    "/" + (String) areaPathsModel.getValueAt(selectedRow, 4) +
                    "/" + (String) areaPathsModel.getValueAt(selectedRow, 5) + "/" );

        }
    }

    /** void actionPerformed(java.awt.event.ActionEvent evt)
     *
     * This methode is called form the Browse Button beside the dss file path display 
     * field or from the Open menu item. It opens a file browser for the user to select
     * a DSS File */

    private void actionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_actionPerformed

        javax.swing.JFileChooser  fc;

        if ( evt.getSource() == jDssFileBrowseButton || evt.getSource() == jOpenMenuItem)
        {
            fc = new javax.swing.JFileChooser ();               // make the file chooser
            fc.setFileSelectionMode(fc.FILES_ONLY);             // display files only
            fc.setCurrentDirectory(lastFile);                   // open the last directory
            fc.setAcceptAllFileFilterUsed(false);               // do not display all files

            // set the file filter to return only DSS files

            fc.setFileFilter(new javax.swing.filechooser.FileFilter(){
                // return true only for files to be displayed
                public boolean accept(java.io.File f)
                {
                    // get the extension of the file
                    String ext = getExtension(f);

                    if ( f.isDirectory() )
                        return true;            // always show direcories
                    else if ( ext == null)
                    {
                        return false;           // dont show files without an extension
                    }
                    else if ( ext.equals("dss"))
                        return true;            // show dss files
                    else
                        return false;           // dont show any other files
                }

                // The description of the file filter
                public String getDescription()
                {
                    return new String("DSS File filter");
                }

                // methode to get a filenames extension
                private String getExtension(java.io.File f) {
                    String ext = null;
                    String s = f.getName();
                    int i = s.lastIndexOf('.');

                    if (i > 0 &&  i < s.length() - 1) {
                        ext = s.substring(i+1).toLowerCase();
                    }
                    return ext;
                }
            });

            int rval;                             // holder for retrun value
            rval = fc.showOpenDialog(this);       // show the dialog
            if ( rval == fc.CANCEL_OPTION )
            {
                return;                           // if the user cancled do nothing
            }
            else if ( rval == fc.APPROVE_OPTION)
            {
                lastFile = fc.getSelectedFile();    // set the last selected file
                fileLoaded = true;                  // set the flag variabble saying a file is loaded
                jDSSFilename.setText( lastFile.getAbsolutePath());

                prefs.put("Last DSS File Opened",lastFile.getAbsolutePath()); // record the last file opened so we can brose to its directory at the next request
                loadDSSFile();
            }
            else
            {
                // some error occured 

                javax.swing.JOptionPane.showMessageDialog(this,
                        "The File Chooser returned and unexpected value: " + rval,
                        "Bad Return Value", javax.swing.JOptionPane.ERROR_MESSAGE);
            }


        }
    }//GEN-LAST:event_actionPerformed

    /**
     * load the user selected DSS file 
     */

    public void loadDSSFile()
    {
        // close the old time series if one exists
        closeDSSFile();

        // make a new time series
        ts = new HecTimeSeries();
        pd = new HecPairedData();

        // open the interfaces to the dss file
        ts.setDSSFileName(lastFile.getAbsolutePath(),true);
        pd.setDSSFileName(lastFile.getAbsolutePath(),true);


        for (int j = 0; j < stageDataStr.length; ++j) {

            CondensedReference[] cr = ts.getCondensedCatalog("/*/*/"+stageDataStr[j]+"/*/*/*/");

            for (int i = 0; i < cr.length; i++) {
                CondensedReference r = cr[i];
                stagePathsModel.addRow(r.toString().substring(1).split("/"));
            }
        }

        jStageTable.clearSelection();

        if ( jStageTable.getRowCount() > 0)
        {
            jStageTable.addRowSelectionInterval(0,0);
        }
    }

    /**
     * Close the the file pointed to by the Timeseries Refernce and set it yo null
     */

    private void closeDSSFile()
    {
        if ( ts != null )
        {
            // tell the dss library that io with this file is done
            ts.done();

            //c lose the file
            ts.close();

            // remove the reference
            ts = null;
        }

        if ( pd != null )
        {
            // tell the dss library that io with this file is done
            pd.done();

            //c lose the file
            pd.close();

            // remove the reference
            pd = null;
        }

        // clear the path display list
        stagePathsModel.setRowCount(0);
    }


    /**
     * run model on the time period indicated in the text boxes
     **/

    private void runRange(int startYear, int stopYear, String startDate, String stopDate)
    {
        String path;
        String tmp;
        HecTime startTime;
        HecTime stopTime;

        //read the stage area curve
        int size = stopYear-startYear+1;
        stageAreaCurve = new PairedDataContainer();
        int rv = pd.read(stageAreaCurve);

        if ( rv == -2)
        {
            javax.swing.JOptionPane.showMessageDialog(this,
                    "No dat found in Stage Area Curve",
                    "Missing Data",
                    javax.swing.JOptionPane.ERROR_MESSAGE);
        }
        else if ( rv == - 3)
        {
            javax.swing.JOptionPane.showMessageDialog(this,
                    "Could not read Stage Area Curve",
                    "Corrupt DSS File",
                    javax.swing.JOptionPane.ERROR_MESSAGE);
        }

        makeAreaTable();

        years = new intArrayContainer(size);
        yearFeedingArea = new HecDoubleArray(size);
        yearRestingArea = new HecDoubleArray(size);
        yearAvgStage = new HecDoubleArray(size);

        for(int yearIndex = 0; yearIndex < size; ++yearIndex )
        {
            String partD = startDate + (startYear+yearIndex);
            path = GetRecordPath(partD);

            // get the window start time
            startTime = new HecTime(partD);
            // set the time to 8 am
            startTime.increment(8,60);
            // set the window back exaustionDays days
            startTime.increment(-exaustionDays,1440);

            // get the window stop time
            tmp = stopDate + (startYear+yearIndex);
            stopTime = new HecTime(tmp);
            stopTime.increment(8,60);

            if ( stopTime.compareTimes(startTime) == -1 )
            {
                tmp = stopDate + (startYear+yearIndex+1);
                stopTime = new HecTime(tmp);
                stopTime.increment(8,60);
            }

            // set the path
            ts.setPathname(path);

            // set the path
            ts.setTimeWindow(startTime,stopTime);

            if ( recordDaily && yearIndex == 0 )
            {
                initYearBuffer();
            }

            fAvg = 0;
            rAvg = 0;
            stageAvg = 0;

            clearAreaTable();
            getYearAverages();

            years.array[yearIndex] = startYear + yearIndex;
            yearFeedingArea.set(yearIndex,fAvg);
            yearRestingArea.set(yearIndex,rAvg);
            yearAvgStage.set(yearIndex,stageAvg);
        }

        if ( recordDaily )
        {
            bufferStageAreaTable();
            dWriter = null;
        }

        displayResults();
    }

    private String GetRecordPath(String partD) {
        String path;
        int pos1, pos2;

        pos1 = currentPath.indexOf("/",1);    // 2nd /
        pos1 = currentPath.indexOf("/",pos1+1); // 3rd /
        pos1 = currentPath.indexOf("/",pos1+1); // 4th /
        pos2 = currentPath.indexOf("/",pos1+1); // 5th /

        // make the path for the current year
        path = currentPath.substring(0,pos1+1)+ partD+currentPath.substring(pos2);
        return path;
    }


    private double LinearInterpolate(PairedDataContainer stageAreaCurve, double num)
    {
        double[] xvals = stageAreaCurve.xOrdinates;

        if (xvals.length == 0 || num < xvals[0] || num > xvals[xvals.length - 1])
        {
            return -1;
        }
        double[] yvals = stageAreaCurve.yOrdinates[0];

        for (int i = 0; i < stageAreaCurve.xOrdinates.length-1; i++)
        {
            double x1 = xvals[i];
            double x2 = xvals[i+1];
            double y1 = yvals[i];
            double y2 = yvals[i+1];

            if (num >= x1 && num <= x2)
            {
                double slope = (y2 - y1) / (x2 - x1);
                double rval = y1+(num - x1)*slope;
                return rval;
            }
        }
        return -2;
    }
    /** makeAreaTable
     *  Use the stage area table to construct an area incrment map.
     *  This will hold the number of new accres flooded in 1/10 of a foot
     *  increments. For example the mapped value for 90 is the number of
     *  acres that flood when the stage moevs from 90 feet tp 90.1 feet */

    void makeAreaTable()
    {
        areaTable = new java.util.HashMap<Double,TableRec>((int)((stageAreaCurve.xOrdinates.length*10+1)/0.75),0.75f);

        int l = stageAreaCurve.xOrdinates.length;

        double min_val = Math.floor(stageAreaCurve.xOrdinates[0]);
        double max_val = Math.ceil(stageAreaCurve.xOrdinates[l-1]);

        java.util.HashMap<Double,TableRec> tempAreaTable = new java.util.HashMap<Double,TableRec>((int)((stageAreaCurve.xOrdinates.length*10+1)/0.75),0.75f);
        for (double x = Math.round(min_val * 10) / 10.0; x < max_val; x = Math.round((x + 0.1) * 10) / 10.0)
        {
            //double NextVal = Math.round((x + 0.1) * 10.0) / 10.0;
            double area2 = LinearInterpolate(stageAreaCurve, x + 0.1);
            double area1 =  LinearInterpolate(stageAreaCurve, x);
            double diff = area2 - area1;

            areaTable.put(x, new TableRec(area2 - area1, 0));
        }
    }

    void makeAreaTableOld()
    {
        java.util.HashMap<Double,Double> table = new java.util.HashMap<Double,Double>((int)((stageAreaCurve.xOrdinates.length*10+1)/0.75),0.75f);
        areaTable = new java.util.HashMap<Double,TableRec>((int)((stageAreaCurve.xOrdinates.length*10+1)/0.75),0.75f);

        int l = stageAreaCurve.xOrdinates.length;

        // the maximum values that will be added to the table
        double min_val = Math.floor(stageAreaCurve.xOrdinates[0]);
        double max_val = Math.ceil(stageAreaCurve.xOrdinates[l-1]);

        // the current position in the stage area curve
        int lowIndex = 0;
        int highIndex = 1;

        double lowStage = Math.round(stageAreaCurve.xOrdinates[lowIndex] * 10) / 10.0;
        double highStage = Math.round(stageAreaCurve.xOrdinates[highIndex] * 10) / 10.0;

        double lowArea = stageAreaCurve.yOrdinates[0][lowIndex];
        double highArea = stageAreaCurve.yOrdinates[0][highIndex];

        // the current value
        double key = min_val;

        //while( key <= max_val)
        for (; key <= max_val; key =( (long)(key * 10) + 1 ) / 10.0)
        {
            if ( key == lowStage )
            {
                table.put(key,lowArea);
            }
            else if ( key == highStage )
            {
                table.put(key,highArea);
            }
            else if ( key < lowStage )
            {
                table.put(key,lowArea);
            }
            else if ( key > highStage )
            {
                while ( key > highStage )
                {
                    highIndex += 1;
                    highStage = Math.round(stageAreaCurve.xOrdinates[highIndex] * 10) / 10.0;
                    highArea = stageAreaCurve.yOrdinates[0][highIndex];

                    lowIndex += 1;
                    lowStage = Math.round(stageAreaCurve.xOrdinates[lowIndex] * 10) / 10.0;
                    lowArea = stageAreaCurve.yOrdinates[0][lowIndex];

                    key =( (long)(key * 10) - 1 ) / 10.0;
                }
            }
            else
            {
                double range = highStage - lowStage;
                double shift = (key - lowStage) / range;
                double ishift = 1.0 - shift;

                double val = (highArea * shift) + (lowArea * ishift);

                table.put(key,val);
            }
        }
        table.put(stageAreaCurve.xOrdinates[l-1],stageAreaCurve.yOrdinates[0][l-1]);


        for( key = min_val; key < max_val; key += 1.0)
        {
            for( int j = 0; j < 10; ++j )
            {
                double k1 = key + (j* 0.1);
                double k2 = key + ((j+1) * 0.1);
                areaTable.put(k1, new TableRec(table.get(k2) - table.get(k1), 0));
            }
        }

    }

    /** clearAreaTable()
     *
     * Reset the depletion counters in the area incrment table
     */

    private void clearAreaTable()
    {
        java.util.Iterator iter = areaTable.values().iterator();

        while( iter.hasNext() )
        {
            TableRec r = (TableRec) iter.next();
            r.count = 0;
        }
    }

    /**
     *  Calculate the feeding and resting acres for a year.
     *  Years with fatal data read acres report a value of -1
     **/

    private void getYearAverages()
    {
        doubleArrayContainer vals = new doubleArrayContainer();

        if ( recordDaily == false )
        {

            int rv = ts.read(vals);

            if ( rv == - 1)
            {
                rAvg = HecDouble.NO_VALUE_SET;
                fAvg = HecDouble.NO_VALUE_SET;
                stageAvg = HecDouble.NO_VALUE_SET;
                return;
            }
            else if ( rv == -2 )
            {
                rAvg = -1;
                fAvg = -1;
                return;
            }
            else if ( rv == -3 )
            {
                rAvg = -1;
                fAvg = -1;
                return;
            }

            // get the rearing acres
            fAvg = getYearFeedingAverage(vals, false);

            //get the spawning acres
            rAvg = getYearRestingAverage(vals, false);

            stageAvg = getYearStageAverage(vals, false);
        }
        else
        {
            dailyTime = new HecTimeArray();

            int rv = ts.read(dailyTime,vals);

            updateDailyArrays();

            if ( rv == -2 )
            {
                rAvg = -1;
                fAvg = -1;
                tAvg = -1;
            }
            else if ( rv == -3 )
            {
                rAvg = -1;
                fAvg = -1;
                tAvg = -1;
            }

            // get the rearing acres
            fAvg = getYearFeedingAverage(vals, true);

            //get the spawning acres
            rAvg = getYearRestingAverage(vals, true);

            stageAvg = getYearStageAverage(vals, true);

            bufferYearData();
        }
    }

    /** getWindowBeginStr()
     *
     * Return the string representation of the begining of the season */

    private String getWindowBeginStr()
    {
        StringBuffer buffer = new StringBuffer();

        if ( seasonStartDay < 10)
        {
            buffer.append("0");
        }

        buffer.append(seasonStartDay);
        buffer.append(getMonthName(seasonStartMonth));

        return buffer.toString();
    }

    /** getWindowEndStr()
     *
     * Return the string representation of the end of the season */

    private String getWindowEndStr()
    {
        StringBuffer buffer = new StringBuffer();

        if ( seasonStopDay < 10)
        {
            buffer.append("0");
        }

        buffer.append(seasonStopDay);
        buffer.append(getMonthName(seasonStopMonth));

        return buffer.toString();
    }

    /** getMonthName(int m)
     *
     *  Convert a numerical mounth identifier into the correct string to be used
     *  in construction of an HecDate object */

    private String getMonthName(int m)
    {
        switch(m)
        {
            case 1:
                return "JAN";

            case 2:
                return "FEB";

            case 3:
                return "MAR";

            case 4:
                return "APR";

            case 5:
                return "MAY";

            case 6:
                return "JUN";

            case 7:
                return "JUL";

            case 8:
                return "AUG";

            case 9:
                return "SEP";

            case 10:
                return "OCT";

            case 11:
                return "NOV";

            case 12:
                return "DEC";

            default:
                return "JAN";
        }
    }

    /** double getYearFeedingAverage(doubleArrayContainer vals)
     *
     *  Get the average feeding acres for ducks in the year of data contained in vals.
     *  The first exaustionDays days are not considered in the average.
     *  The daily values are not not recorded */

    /** double getYearFeedingAverage2(doubleArrayContainer vals)
     *
     *  Get the average feeding acres for ducks in the year of data contained in vals.
     *  The first exhaustion Days days are not considered in the average.
     *  The daily values are not recorded */

    private double getYearFeedingAverage(doubleArrayContainer vals, boolean dailyExhaustionSet)
    {
        double total = 0, sum;

        int num = vals.array.length - exaustionDays;

        // get the inital exaustion depth
        double currentMin = exaustionDepth = getMin(vals,0,exaustionDays);

        for( int i = exaustionDays; i < vals.array.length; ++i )
        {
            // check to see if the exaustion depth needs to be updated
            if ( currentMin == vals.array[i-exaustionDays] )
            {
                currentMin = getMin(vals,i-exaustionDays+1,exaustionDays);
                if ( currentMin > exaustionDepth)
                {
                    exaustionDepth = currentMin;
                }
            }

            if (dailyExhaustionSet){
                dailyExaustion.set(i,exaustionDepth);
            }

            // determin the viable feeding range for this day

            double hs = vals.array[i];
            double ls = (hs - maxDepth > exaustionDepth) ? hs - maxDepth : exaustionDepth;

            // get the integer bounding values for the current feeding range
            int lowVal = (int) ls;
            int highVal = ( (int) hs == hs ) ? (int) hs : (int) (hs + 1);

            // round the high stage nad low stage to 10th of a foot increments
            hs = ((int) (hs * 10)) / 10.0;
            ls = ((int) (ls * 10)) / 10.0;

            sum = 0;

            // add one to the depletion counter for each band in the range highstage to low stage
            if ( ls < hs )
            {
                for( int j = lowVal; j <= highVal; ++j )
                {
                    for( int k = 0; k < 10; ++k )
                    {
                        double key = j + (k * 0.1);
                        if ( ls <= key && key < hs)
                        {
                            TableRec r = areaTable.get(key);
                            if (r != null && r.count < depletionDays)
                            {
                                r.count += 1;
                                sum += r.area;
                            }
                        }
                    }
                }
            }

            total += sum;

            dailyFeeding.set(i,sum);
        }

        return total /= num;
    }

    /** double getYearRestingAverage(doubleArrayContainer vals)
     *
     *  Get the average resting acres for ducks in the year of data contained in vals.
     *  The first exaustionDays days are not considered in the average.
     *  The daily values are recorded */

    /** double getYearRestingAverage2(doubleArrayContainer vals)
     *
     *  Get the average resting acres for ducks in the year of data contained in vals.
     *  The first exaustionDays days are not considered in the average.
     *  The daily values are not recorded */

    private double getYearRestingAverage(doubleArrayContainer vals, boolean dailyRestingSet)
    {
        double total = 0, hVal;

        int num = vals.array.length - exaustionDays;

        for( int i = exaustionDays; i < vals.array.length; ++i )
        {
            double hs = vals.array[i];
            hVal = getAreaForStage(hs);

            if (dailyRestingSet){
                dailyResting.set(i,hVal);
            }

            total += hVal;
        }

        return total /= num;
    }

    /** double getYearStageAverage(doubleArrayContainer vals)
     *
     *  Get the average stage for the year of data contained in vals.
     *  The first exaustionDays days are not considered in the average.
     *  The daily stages are not recorded */

    /** double getYearStageAverage2(doubleArrayContainer vals)
     *
     *  Get the average stage for the year of data contained in vals.
     *  The first exaustionDays days are not considered in the average.
     *  The daily stages are recorded */

    private double getYearStageAverage(doubleArrayContainer vals, boolean dailyStageSet)
    {
        double val, total = 0;

        int num = vals.array.length - exaustionDays;

        if (dailyStageSet){
            for( int i = 0; i < exaustionDays; ++i )
            {
                dailyStage.set(i,vals.array[i]);
            }
        }

        if (dailyStageSet){
            for( int i = exaustionDays; i < vals.array.length; ++i)
            {
                val = vals.array[i];

                dailyStage.set(i,val);

                total += val;
            }
        } else {
            for( int i = exaustionDays; i < vals.array.length; ++i)
            {
                total += vals.array[i];
            }
        }


        return total / vals.array.length;
    }

    /** double getAreaForStage(double stage)
     *
     * Find the area for a stage in a stage area curve that records only integer stags.
     * Linear Interpolation is used if the input stage is not an integer
     */

    private double getAreaForStage(double stage)
    {
        int pos1, pos2;

        double val1, val2;

        if ( stage == (int) stage )
        {
            pos1 = java.util.Arrays.binarySearch(stageAreaCurve.xOrdinates,(int) stage);
            return (pos1 >= 0) ? stageAreaCurve.yOrdinates[0][pos1] : 0;
        }
        else
        {
            pos1 = java.util.Arrays.binarySearch(stageAreaCurve.xOrdinates,(int) stage);
            pos2 = java.util.Arrays.binarySearch(stageAreaCurve.xOrdinates,(int) stage+1);

            if ( pos1 >= 0 && pos2 >= 0)
            {
                val1 = stageAreaCurve.yOrdinates[0][pos1];
                val2 = stageAreaCurve.yOrdinates[0][pos2];

                double scale = stage - (int) stage;
                double iscale = 1 - scale;

                return (iscale * val1) + (scale * val2);
            }
            else if ( pos1 >= 0 )
            {
                return stageAreaCurve.yOrdinates[0][pos1];
            }
            else if ( pos2 >= 0 )
            {
                return stageAreaCurve.yOrdinates[0][pos2];
            }
            else
            {
                return 0;
            }
        }
    }

    /** getMin(doubleArrayContainer vlas, int idx, int window)
     *
     *  return the minimum value found in the container vals betwenn the
     * indeces idx and idx + window - 1 */

    private double getMin(doubleArrayContainer vals, int idx, int window)
    {
        double min = vals.array[idx];
        for( int i = idx; i < idx+window; ++i)
        {
            if ( vals.array[i] < min)
            {
                min = vals.array[i];
            }

        }

        return min;

    }

    /** getMax(doubleArrayContainer vlas, int idx, int window)
     *
     *  return the maximum value found in the container vals betwenn the
     * indeces idx and idx + window - 1 */

    private double getMax(doubleArrayContainer vals, int idx, int window)
    {
        double max = vals.array[idx];
        for( int i = idx; i < idx+window; ++i)
        {
            if ( vals.array[i] > max)
            {
                max = vals.array[i];
            }

        }

        return max;

    }

    /** void displayResults()
     *
     * Write the yearly avearge table into a string buffer,
     * display the buffer and write the buffer to file, whose name
     * is derieved form the selected gage and stage area curve */

    void displayResults()
    {
        StringBuffer buffer = new StringBuffer();

        buffer.append("DSS File:\t");
        buffer.append(ts.DSSFileName());
        buffer.append("\n");

        buffer.append("Stage Elevatopn Path:\t");
        buffer.append(ts.pathname());
        buffer.append("\n");

        buffer.append("Stage Area Path:\t");
        buffer.append(pd.pathname());
        buffer.append("\n");

        buffer.append("Time Window:\t");
        buffer.append(jSeasonField.getText() + "\n");
        buffer.append("Days untill Exaustion : " + exaustionDays + " Days\n");
        buffer.append("Days untill Depletion : " + depletionDays + " Days\n");

        buffer.append("\n\n");

        buffer.append("Year\tStage\tFeeding\tResting\n\n");

        for(int i = 0; i < years.array.length; ++i )
        {
            buffer.append(years.array[i]);
            buffer.append("\t");
            buffer.append(yearAvgStage.value(i).toString());
            buffer.append("\t");
            buffer.append(yearFeedingArea.value(i).toString());
            buffer.append("\t");
            buffer.append(yearRestingArea.value(i).toString());
            buffer.append("\n");
        }

        buffer.append("\nAverage Season Stage\t");
        buffer.append(yearAvgStage.average());
        buffer.append("\n");
        buffer.append("Min Season Stage\t");
        buffer.append(yearAvgStage.minimum());
        buffer.append("\n");
        buffer.append("Maximum Yearly Stage\t");
        buffer.append(yearAvgStage.maximum());
        buffer.append("\n\n");

        buffer.append("Avg Feeding\tAvg Resting\n");
        buffer.append(yearFeedingArea.average().string(1,true));
        buffer.append("\t");
        buffer.append(yearRestingArea.average().string(1,true));
        buffer.append("\n");

        String fileName =  ts.aPart() + "_" + ts.bPart() + "_" + ts.fPart();
        fileName += ".evd";
        String filePath = outputDirPath + "/" + fileName;
        try
        {
            java.io.FileWriter writer = new java.io.FileWriter(filePath);
            writer.write(buffer.toString());
            writer.close();
        }
        catch(java.io.IOException io_excep)
        {
            javax.swing.JOptionPane.showMessageDialog(this,
                    "Error writing file " + filePath,
                    "IOError",
                    javax.swing.JOptionPane.ERROR_MESSAGE);

        }

        ReportDisplay rd = new ReportDisplay();
        rd.setText(buffer.toString());
        rd.setTitle(fileName);
        rd.setVisible(true);

        if ( recordDaily )
        {
            displayDailyResults();
        }
    }

    /** void displayDailyResults
     *
     *  Display the buffer containing the daily calculated values for
     *  feeding area, and resting area, also display the daily stage value
     *  and the exaustion stage level. The function also writes the buffer to
     *  file  "daily_results.txt" in the same directory as the program. This file
     * is use fule for verifing the models operation */

    private void displayDailyResults()
    {
        try
        {
            dWriter = new java.io.FileWriter("daily_results.txt");

            dWriter.write(dBuffer.toString());
            dWriter.flush();


        }
        catch( java.io.IOException e)
        {
            javax.swing.JOptionPane.showMessageDialog(this,
                    "Error writing file " + "daily_results.txt",
                    "IOError",
                    javax.swing.JOptionPane.ERROR_MESSAGE);
        }

        ReportDisplay rd = new ReportDisplay();
        rd.setText(dBuffer.toString());
        rd.setTitle("daily_results.txt");
        rd.setVisible(true);

    }

    /** void initYearBuffer()
     *
     * This function is misnamed it should be initDaily Buffer.
     * The function initalises the buffer that holds the dailly
     * calculations for each year */

    private void initYearBuffer()
    {
        dBuffer = new StringBuffer();
        dBuffer.append("DSS File:\t");
        dBuffer.append(ts.DSSFileName());
        dBuffer.append("\n");

        dBuffer.append("Stage Elevatopn Path:\t");
        dBuffer.append(ts.pathname());
        dBuffer.append("\n");

        dBuffer.append("Stage Area Path:\t");
        dBuffer.append(pd.pathname());
        dBuffer.append("\n");

        dBuffer.append("Time Window:\t");
        dBuffer.append(jSeasonField.getText() + "\n");
        dBuffer.append("Days until Exaustion: " + exaustionDays + " Days\n");
        dBuffer.append("Max Rearing Depth: " + maxDepth + " Feet\n");
        dBuffer.append("\n\n");

        dBuffer.append("Year\tStage\tFeeding\tResting\tExaustion Stage\n");
    }

    /** void bufferYearData()
     *
     * This function saves the dailly values for the current year to a buffer
     * the buffer is diplayed with displayDailyResults */

    private void bufferYearData()
    {

        for(int i = 0; i < dailyTime.getIntArray().length; ++i )
        {
            dBuffer.append( dailyTime.element(i).month() + "/"  +
                    dailyTime.element(i).day() + "/"  +
                    dailyTime.element(i).year());
            dBuffer.append("\t");
            dBuffer.append( dailyStage.element(i).string(2,true) );
            dBuffer.append("\t");
            dBuffer.append( dailyFeeding.element(i).string(1,true ) );
            dBuffer.append("\t");
            dBuffer.append( dailyResting.element(i).string(1,true) );
            dBuffer.append("\t");
            dBuffer.append( dailyExaustion.element(i).string(1,true) );
            dBuffer.append("\n");
        }
    }

    /** void bufferStageAreaTable()
     *
     * This function writes the incremental stage area curve table used by the model
     * into the buffer that holds the daily results. The table is an incremental table,
     * it shows the change in flooded area at a given elevation not the flooded elevation at
     * that elevation. To find the flooded area at an elevation sum all table entries equal to
     * or less than the desired elevation */

    private void bufferStageAreaTable()
    {
        int l = stageAreaCurve.xOrdinates.length;

        dBuffer.append("\n\nStage\tArea\n");

        for( int i = (int) stageAreaCurve.xOrdinates[0]; i < stageAreaCurve.xOrdinates[l-1]; ++i)
        {
            for( int j = 0; j < 10; ++j)
            {
                double key = i + (j * 0.1);
                double val = (areaTable.get(key)).area;

                dBuffer.append(key + "\t" + val + "\n");
            }
        }
    }

    /** void updateDailyArrays()
     *
     * Make sure that the arrays used to hold the daily values for the current year
     * exist and are the correct size */

    private void updateDailyArrays()
    {
        int size = dailyTime.getIntArray().length;

        if ( dailyStage == null )
        {
            dailyStage = new HecDoubleArray(size);
        }
        else
        {
            dailyStage.setSize(size);
        }

        if ( dailyResting == null )
        {
            dailyResting = new HecDoubleArray(size);
        }
        else
        {
            dailyResting.setSize(size);
        }

        if ( dailyFeeding == null )
        {
            dailyFeeding = new HecDoubleArray(size);
        }
        else
        {
            dailyFeeding.setSize(size);
        }

        if ( dailyExaustion == null )
        {
            dailyExaustion = new HecDoubleArray(size);
        }
        else
        {
            dailyExaustion.setSize(size);
        }


    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JTable jAreaTable;
    private javax.swing.JButton jButton1;
    private javax.swing.JCheckBox jCalcDailyCBox;
    private javax.swing.JTextField jDSSFilename;
    private javax.swing.JFormattedTextField jDepletionField;
    private javax.swing.JButton jDssFileBrowseButton;
    private javax.swing.JFormattedTextField jDurField;
    private javax.swing.JMenu jFileMenu;
    private javax.swing.JLabel jLabel1;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JLabel jLabel4;
    private javax.swing.JLabel jLabel5;
    private javax.swing.JLabel jLabel6;
    private javax.swing.JLabel jLabel7;
    private javax.swing.JLabel jLabel8;
    private javax.swing.JFormattedTextField jMaxDepthText;
    private javax.swing.JMenuBar jMenuBar;
    private javax.swing.JMenuItem jOpenMenuItem;
    private javax.swing.JButton jOutputPathButton;
    private javax.swing.JTextField jOutputPathField;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JPanel jPanel2;
    private javax.swing.JPanel jPanel3;
    private javax.swing.JMenuItem jPrefsItems;
    private javax.swing.JCheckBox jRetainPeriodCBox;
    private javax.swing.JButton jRunButton;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JScrollPane jScrollPane2;
    private javax.swing.JTextField jSeasonField;
    private javax.swing.JTable jStageTable;
    private javax.swing.JFormattedTextField jStartText;
    private javax.swing.JFormattedTextField jStopText;
    // End of variables declaration//GEN-END:variables

    //User Variables
    private java.io.File lastFile;
    private boolean fileLoaded;
    private HecTimeSeries ts;
    private HecPairedData pd;
    private PairedDataContainer stageAreaCurve;
    private String currentPath;
    private intArrayContainer years;
    private HecDoubleArray yearFeedingArea;
    private HecDoubleArray yearRestingArea;

    private HecDoubleArray yearAvgStage;
    private double fAvg;                        // feeding area average acres
    private double rAvg;
    private double tAvg;
    private double stageAvg;

    private class TableRec extends Object
    {
        public TableRec(double a, int c)
        {
            area = a;
            count = c;
        }

        public String toString() { return "{area: " + area + " count: " + count + "}"; }

        public double area;
        public int count;
    };

    private java.util.HashMap<Double,TableRec> areaTable;

    javax.swing.text.NumberFormatter df;
    javax.swing.text.NumberFormatter df2;
    javax.swing.text.NumberFormatter df3;
    javax.swing.text.MaskFormatter yf1;
    javax.swing.text.MaskFormatter yf2;

    //Table variables

    javax.swing.table.DefaultTableModel stagePathsModel;
    javax.swing.table.DefaultTableModel areaPathsModel;

    //Prefences variables
    private Preferences prefs;
    private String stageDataStrings;
    private String stageAreaStrings;
    private String[] stageDataStr;
    private String[] stageAreaStr;
    private String outputDirPath;
    private int seasonStartDay;
    private int seasonStopDay;
    private int seasonStartMonth;
    private int seasonStopMonth;
    private float maxDepth;
    private int exaustionDays;
    private double exaustionDepth;
    private int depletionDays;

    private boolean recordDaily;
    private HecTimeArray dailyTime;
    private HecDoubleArray dailyStage;
    private HecDoubleArray dailyFeeding;
    private HecDoubleArray dailyResting;
    private HecDoubleArray dailyExaustion;
    private StringBuffer dBuffer;
    private java.io.FileWriter dWriter;
}
